#The purpose of this script is to run the jobs generated by "make_Nbody.py". Actual N-body simulations
import pandas as pd
import numpy as np
import os
import sys
import rebound
import time
import math
import systems.sys_params as sysp

# planetary radii are hill radii, and thus if hill radii touch (i.e. collision),
# causes simulation to stop running and have flag for whether sim stopped due to collision
def collision(reb_sim, col):
    reb_sim.contents._status = 5
    return 0

def get_M(e, w, T, P, epoch):
    f_midtr = np.pi/2 - w   #at mid-transit
    E_midtr = 2*np.arctan(np.tan(f_midtr/2) * np.sqrt((1-e)/(1+e))) #E and f always in same half of ellipse
    M_midtr = E_midtr - e*np.sin(E_midtr)
    M_epoch = M_midtr + (epoch - T)*2*np.pi/P
    return M_epoch

for i in ["1","2","3"]:
    e, w, n = data["e%s"%i], data["w%s"%i], 2*np.pi/data["P%s"%i]
    E_midtr = 2*np.arctan(np.sqrt((1-e)/(1+e))*np.tan((np.pi/2 - w)/2))
    M_midtr = E_midtr - e*np.sin(E_midtr)
    data["M%s"%i] = M_midtr + n*(data["T%s"%i] - min_transit_times - M_buffer)

#arguments
system = sys.argv[1]
id = int(sys.argv[2])
maxorbs = float(sys.argv[3])
Nplanets = int(sys.argv[4])
shadow = int(sys.argv[5])
name = sys.argv[6]

#load data
data = pd.read_csv('systems/%s_data.csv'%system)
d = data.iloc[id]

#set up simulation
sim = rebound.Simulation()
sim.integrator = 'whfast'
sim.G = 1
sim.ri_whfast.safe_mode = 0
sim.collision = 'direct'
sim.collision_resolve = collision

#add sun
Ms = d["Ms"]
sim.add(m=Ms)

#minimum hill radius
earth = 0.000003003
a, mut_hill = [], []
for i in range(1, Nplanets + 1):
    a.append(((d["P%d"%i]/365)**2 * Ms)**(1./3.))
for i in range(1, Nplanets):
    mut_hill.append(a[i]*((d["m%d"%i]+d["m%d"%(i+1)])*earth/Ms/3.)**(1./3.))
# Note: This is a smaller estimate than the true mut_hill - missing 2*pi & mean(a[i]+a[i+1])
minhill = min(mut_hill)

#add planets
nomass_sys, vaneye_sys, danjh_sys = sysp.get_system_lists()
for i in range(1, Nplanets + 1):
    m, P = d["m%d"%i]*earth, d["P%d"%i]
    if system in nomass_sys:
        e = d["e%d"%i]
        w = d["w%d"%i]
        M = d["MA%d"%i]
    elif system in vaneye_sys:
        e = d["e%d"%i]
        w = d["w%d"%i]
        min_MidTransitTime = np.min((data["T1"], data["T2"], data["T3"]))
        M = get_M(e, w, d["T%d"%i], P, min_MidTransitTime)
    elif system in danjh_sys:
        e = np.sqrt(d["h%d"%i]**2 + d["k%d"%i]**2)      # sqrt(h^2 + k^2)
        w = np.arctan2(d["h%d"%i], d["k%d"%i])          # arctan2(h/k)
        epoch = 780
        M = get_M(e, w, d["T%d"%i], P, epoch)           # T = epoch = BJD-2,454,900
        m *= Ms     #dan jontoff-hutter planetary masses scaled to 1 solar mass.
    else:
        raise Exception('system is not recognized')
        sys.exit(1)
    sim.add(m=m, P=P*2*np.pi/365., e=e, omega=w, M=M, r=minhill) #G=1 units!
sim.move_to_com()

#shadow system
if shadow == 1:
    kicksize=1.e-11
    sim.particles[2].x += kicksize

#timestep
dt = 2.*math.sqrt(3)/100.
P1 = sim.particles[1].P
sim.dt = dt*P1              # ~3% orbital period
tmax = maxorbs*P1

#save simulation archive
sim.initSimulationArchive('output/%s_SA.bin'%name, interval=tmax/1000.)     #save checkpoints.

#simulate
E0 = sim.calculate_energy()
t0 = time.time()
print("starting simulation")
sim.integrate(tmax)                                                         #will stop if collision occurs
print("finished simulation")
Ef = sim.calculate_energy()
Eerr = abs((Ef-E0)/E0)

#need to store the result somewhere
f = open('systems/%s_Nbodyresults.csv'%system, "a")
f.write('%s, %d, %d, %e, %e, %e, %e, %e \n'%(name,id,shadow,maxorbs,P1,sim.t,Eerr,time.time()-t0))

